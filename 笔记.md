### Part1
1.	Java（1）java语言（2）java开发平台
2.	Java由四方面组成：Java编程语言、Java类文件格式、Java虚拟机和Java应用程序接口(Java API)。
3.	Java平台由Java虚拟机（Java Virtual Machine，简称JVM）和Java 应用编程接口（Application Programming Interface，简称API）构成
4.	源代码文件.java --> 编辑器（使用java.exe编译过程） --> 字节码.class --> java解释器（For Windows、For MacOS、For UNIX）(java虚拟机) （使用java.exe解释过程）--> Windows、Mas、Unix
5.	应用平台：
桌面应用开发(Java核心、基础)：
JavaSE(Java Standard Edition)
企业级应用开发：
JavaEE(Java Enterprise Edition)
手机等移动产品开发：
JavaME(Java Micro Edition)
Android开发
6.	javaSE：java基础知识     桌面开发和低端商务应用
javaEE ：web应用开发	大型网站、大型企业级应用
java ME ：做游戏开发的	为机顶盒、移动电话和PDA之类嵌入式消费电子设备提供的Java语言平台,包括虚拟机和一系列标准化的Java API
7.	java虚拟机是软件模拟的计算机，可以在任何处理器上（无论是在计算机中还是在其它电子设备中）安全并且兼容的执行保存在.class文件中的字节码。
8.	了解JDK目录：
bin: JDK包含的一些开发工具执行文件，包括编译器、解释器和一些工具 
include: Win32字目录，是本地方法文件
jre: 是java程序运行环境的根目录 
lib: Java开发工具要用的一些库文件
src.zip：归档的Java源代码
db：纯Java开发的数据可 Derby，是一个开源的100%Java开发的关系数据库 
9.	集成开发环境：集程序编辑，编译，运行调试，打包，发布等功能于一体的软件
10.	新建java源文件：File --> New --> Class
11.	Java注释：
块注释(/*注释的内容*/)
行注释(//注释内容)
文档的注释(/** 注释的内容*/)
### Part2
1.	标识符：
（1）	概念：对于变量，常量，函数，语句块也有名字，我们统统称之为Java标识符；用来给类、对象、方法、变量、接口和自定义数据类型命名的。
（2）	组成：数字，字母和下划线(_)，美元符号（$）组成，只能以字符、“_”或“$”开头 ；大小写区别对待，并且未规定最大长度；不能是Java关键字。
（3）	命名约定：
类和接口名。每个字的首字母大写，含有大小写。
例如，MyClass，HelloWorld，Time等。 
方法名。首字母小写，其余的首字母大写，含大小写。尽量少用下划线。
例如，myName，setTime等。 
常量名。基本数据类型的常量名使用全部大写字母，字与字之间用下划线分隔。对象常量可以大小混些。
例如，SIZE_NAME。 
变量名。可大小写混写，首字符小写，不用下划线，少用美元符号。给变量命名时尽量做到见名知意。
（4）	Java关键字 第二章java基础P6 
2.	数据类型：数据类型是程序设计语言描述事物、对象的方法。Java数据类型分为基本类型和引用类型两大类。
（1）基本类型
–	整数类型  byte 1 , short 2 , int 4 , long 8
用于表示没有小数部分的数值，它允许是负数
–	浮点类型  double 8 , float 4
用于表示有小数部分的数值
–	字符类型  char 2
用于表示单个字符。通常用来表示字符常量
–	布尔类型  Boolean
有false和true两个值,用来判定逻辑条件；整数值和布尔值之间不能进行相互转换
（2）引用类型
–	类
–	接口
–	数组
–	枚举
3.	变量：变量是在程序运行过程中其值可以被改变的量。
（1）	变量包括变量名、变量值两部分
（2）	定义：1）声明
变量声明的格式如下：
数据类型 变量名1[,变量名2，...];	
例如：int x，y，z；在该语法格式中，变量名之间使用“，”分隔。
 2）初始化
也可以在声明多个变量时对变量进行赋值，语法格式如下：
 数据类型 变量名称1=值1，变量名称2=值2，…变量名称n=值n；
	  也可以在声明变量时，有选择的进行赋值，例如：int x，y=10，z；
	  程序中可以通过变量名称来引用变量中存储的值，也可以为变量重新赋值
4.	常量: 在程序运行过程中其值始终保持不变的量。Java使用关键字final来定义常量。
a)	定义：final 数据类型 常量名称 = 值 ;

5.	运算符:
算数运算符	+   -   *   /   %
自增运算符、自减运算符	++    --
关系运算符	>   >=   <   <=   ==   !=
逻辑运算符	&&   ||    !    
三元运算符	?:
赋值运算符	=     +=    -=    *=      %= 
位运算符	&    |    ^
字符串连接运算符	+
instanceof比较	instanceof检查对象是否是某种类型
1）	自增自减：操作数不能是数值，只能是变量。
优先级：
运算符	结合性
！~  ++ -- + - (一元运算) 	从右向左
* / %	从左向右
+ - 	从左向右
<< >> 	从左向右
<   <=   >   >=   instanceof	从左向右
==   !=	从左向右
&	从左向右
^	从左向右
|	从左向右
&&	从左向右
||	从左向右
? :	从右向左
=  +=  -=  *=   /=   %=  	从右向左

6.	表达式：
（1）	概念：符合一定语法规则的运算符和操作数的序列
Eg: a 、 5.0 + a 、(a – b )* c - 4
（2）	类型、值：表达式中操作数进行运算得到的结果称为表达式的值；表达式值的数据类型即为表达式的类型
（3）	运算顺序：按照运算符的优先级由高到低执行
7.	类型转换：基本数据类型之间可以进行相互转换
（1）	隐试转换：进行类型加宽转换时可以自动实现，被称为**。
Eg：int n = 5;  double f = n;
（2）	强制转换：进行类型收缩时转换必须进行显示转换，被称为**。
Eg: double f = 5.5 ; int n = (int) f ;
（3）	数据类型 容量大小排序
Byte 1 -> short 2 -> (char 2) -> int 4 -> long 8 -> float 4 -> double 8   
Byte、short、char 之间不会相互转换，他们三者在计算时首先转换为int类型
double转换成float类型，由于double中存在小数点的情况，因此直接加强制转换时转换不过来的（infinity）
（4）	实心箭头，表示无信息丢失的转换；有3个虚箭头，表示可能有精度损失的转换。
 
8.	顺序流程：按照语句顺序依次执行一系列语句(或语句块)
9.	分支流程: 条件语句使部分程序可根据某些表达式的值被有选择的执行。
条件分支流程：
(1)	if ……else
if ( 条件表达式1 ) {
语句块1
} else if（ 条件表达式2 ) {
语句块2
}
...
else if（ 条件表达式n-1 ){
语句块n-1
} else {
语句块n
}	--->重复地交替出现if...else if ...的情况
(2)	switch……case
switch ( 表达式 ) {
case constant1：
语句;
break;
case constant2：
语句;
break;
default:
语句;	
break;
}
1. 表达式必须为char、byte、short、int或enum(枚举类型).
2.case常量必须与switch表达式类型相同，且必须是编译时常量.
3.switch只检查相等性.
10.	循环流程：根据条件，要求程序反复执行某操作。
（1）	for  循环
while循环
do…while循环
增强型for循环
			用于数组或集合的遍历
					For(类型 变量名：数组或集合){
 	循环体
}
（2）	完整的循环 一般包含4部分
a)	初始化部分：设置循环的初始条件
b)	循环体部分：被反复执行的代码
c)	迭代部分：用来更新循环控制条件
d)	终止部分：退出循环的条件判断
### Part3
1.	数组：一组具有同类型
2.	特点：
a.	生命周期内长度固定不变
b.	可存储 基本数据类型、引用数据类型元素
c.	同一个数组中存储相同类型元素
d.	数组中的元素有先后顺序，其顺序位置由下标决定
3.	Java中数组作为组数类（Array）的实例来处理
4.	声明语法：
-	Array_type array_Name[];
-	Array_type []array_Name;
-	Eg:  int ids[];
   String[] stuNo;  (空格的位置 和 有无 并没有影响)
5.	初始化：
-	静态初始化：数组元素的初始化值直接由括在大括号“{ }”之间的数据给出。元素不多且有限。
array_type array_Name={element1[, element2…]};
-	动态初始化：先用new操作符为数组分配内存，然后才为每一个元素赋初值。
array_Name = new array_type [ arraySize];
6.	多维数组：多维数组可以看成是数组的数组，即多维数组的每一个元素可以看成是低维数组。
7.	二维数组声明：
-	Array_type  array_Name[][];
-	Array_type  [][]array_Name;
-	Array_type[]  array_Name[];
8.	初始化
-	静态
Int number[][] = {{1,2},{3,4},{5,6}};
Char ch[][] = {{‘a’,’b’},{‘c’,’d’},{‘e’,’f’}};
-	动态
Long[][] attay_long = new long[5][5];
String[][] names = new String[3][4];
9.	Java.util.Arrays  类能方便的操作数组，它提供的所有方法都是静态的
常用：
a.	copyOf 数组的复制
b.	Fill 数组元素的初始化
c.	Sort 数组的排序
### Part4
1.	面向对象程序设计 三个特点：  封装、继承、多态
2.	OOP(面向对象的设计思想)共性
-	具有一定的状态（数据）：静态属性
-	具有一定的行为（功能）：动态属性
3.	类：一种抽象的数据类型，对同种对象的集合与抽象，对具有共同行为和属性的若干对象的统一描述体。
4.	对象：现实世界中某个存在的实体在计算机逻辑中的映射和体现。
5.	声明语法：
-	[修饰符] class 类名{
-	     [private/protected/public] 成员的声明和定义；
-	}
6.	对象的实例化
a)	<类名>  <对象名> = new <类名> ([参数1，参数2,…]) ;
b)	或
c)	<类名>  <对象名>；
d)	<对象名> = new <类名> ([参数1，参数2,…]) ;
Eg:
e)	Student mary = new Student();
f)	Student lily = new Student();
7.	访问属性：
<对象名>.<属性名>
访问方法：
<对象名>.<方法名>([<参数1>,<参数2>,…]);
Student mary = new Student();
mary.name = "mary";
mary.sex = "femal";
mary.age = 20;
mary.study();
8.	类体 – 成员方法
Java中方法只能定义在类中，称为类的成员方法
-	[方法修饰符]方法返回值 方法名([<参数列表>]){
-	方法体；
-	}
9.	成员方法修饰符(说明方法的访问权限): public 、 private 、 protect 、 final 、 static 、 abstract 、 synchronized
10.	返回值用return 语句来实现 
11.	方法体：
-	包含了实现方法功能的java语言程序代码
-	方法体中可以定义局部变量，它的作用域仅在方法题内
-	方法体用“{}”阔起来
12.	方法重载：类中两个以上的同名方法，参数类型或个数不同。
（1）	依据：
方法名相同
参数列表必须不同
（2）	注:
返回值可以不同（返回值不作为重载的依据）
是否静态的也不作为重载依据
重载的方法之间可以相互调用
13.	初始化 : 开辟内存单元同时对数据成员给出明确的值
14.	构造方法：
-	功能：初始化对象
-	方法名：与类名相同
-	参数：可有可无
-	返回值：不能确定返回值（不能写void  空着 不写就好了）
-	内容：任意，通常只包含成员赋值语句
-	调用：创建对象时自动调用
-	创建：当有指定构造方法，无论是有参、无参的构造方法，都不会再自动添加无参的构造方法。
15.	-   对象生命周期中只调用一次构造方法
-	一个类中没有定义构造方法，java编译器会自动产生一个默认构造方法（无参、无程序代码）；有明显声明的构造方法，java将不会产生默认构造方法
-	在一个类中可以定义多个构造方法，但构造方法的参数列表不能相同
16.	方法传递
-	值传递：方法接收的是调用者提供的变量的值
-	引用传递：方法接受的是调用者提供的变量地址
-	一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。
17.	方法参数：
-	基本数据类型：不会改变值实参的值
-	对象引用类型：方法体内通过引用改变了实际参数对象的内容
18.	PPPPPPP３８！！！java参数传递机制
19.	
20.	垃圾收集器:
-	对于程序不再使用的内存资源，“垃圾收集器”能自动将其释放
-	垃圾收集器受JVM的控制，JVM决定什么时候运行收集器
（1）	JVM感到内存不足时
（2）	Java程序中可以请求JVM运行，但无法保证JVM会答应请求
-	垃圾收集条件：没有线程能够访问对象时，该对象就是适合进行垃圾收集的
-	回收情况：空引用、隔离引用
21.	包(package)：命名空间，避免命名冲突
-	必须放在源程序的除注释外的第一行。
-	包的名称就像是 姓，class 名称 就像是名字
Eg: java.lang.String
22.	如果希望自己的类从属于一个包，可以使用package 关键字
23.	使用方法：
-	系统内置包
-	自定义包
-	第三方提供的包
24.	变量：
1） 成员变量：在类中定义，用来描述对象要有什么
Java会给成员变量一个初始值
2） 局部变量：在类的方法中定义，在方法中临时保存数据。
		Java不会给局部变量赋初始值
	局部变量和成员变量重名时，会优先选择局部变量
25.	几个重要的包：
26.	java.lang
a)	包含一些形成语言核心的类，如String、Math、Integer和Thread。
27.	 java.awt
a)	包含了构成抽象窗口工具包（AWT）的类，这个包被用来构建和管理应用程序的图形用户界面。
28.	 java.applet
a)	包含了可执行applet 特殊行为的类。 
29.	java.net
a)	包含执行与网络相关的操作的类和处理接口及统一资源定位器(URLs)的类。
30.	java.io
a)	包含处理I/O 文件的类。 
31.	java.util
a)	包含为任务设置的实用程序类，如随机数发生、定义系统特性和使用与日期日历相关的函数。

### Part5

1．	继承：从已有的类(父类)产生一个新的子类，子类通过继承自动拥有父类的非私有的属性和方法，继承是实现类的重用、软件复用的重要手段

2．	语法
-	Class 子类名称 extends  父类名称{
-	扩充或修改的属性或方法;
-	}

3．	要点:
Java中的单继承机制：一个类只能有一个直接父类
Final修饰的类不能有子类；String是典型特例
Object类是所有java类的顶级父类

4．	从本质上讲，实例化子类对象时系统会先调用父类的构造方法，再调用子类的构造方法。

5．	JVM默认会调用父类中无参数的构造方法，若父类中没有无参数的构造方法，程序会报错。

6．	引用父类中的属性或方法 —— super
Super.属性  super.方法（）
注：子类只能访问父类中 的protected和 public类型的属性或方法。

7．	重写：子类对父类中声明（定义）的方法进行重新实现的改造称为方法重写（override）

8．	重写规则：
-	返回值类型一致
-	具有相同的方法名
-	参数列表必须相同//不同也完全没影响哎……什么情况？？？
-	不能重写标识为final 的方法
-	不能缩小访问的权限！所以!可以放大访问权限，private换成public 也是可以的！！！！！！
-	不能重写不能被继承的方法。如：父类的private方法

9．	抽象类：abstract修饰的类
-	不能实例化对象
-	类中可以定义抽象方法（abstract修饰的方法）
-	抽象类中可以没有抽象方法。

10．	子类继承抽象类必须实现抽象类中所有的抽象方法，否则子类也必须定义为抽象类。

11．	接口 的定义interface
定义：
–	interface 接口名称 {
•	//接口中的常量声明
•	//接口中的抽象方法声明
–	}

12．	接口 的实现 implements
class 类名 implements 接口名 {
  ……
}

13．	要点
-	一个类可以同时实现多个接口
-	一个接口可以被多个无关的类实现
-	类实现接口必须实现接口中所有的抽象方法，否则必须定义为抽象类

14．	接口的继承
Java中接口可以继承接口，与类的继承概念一致，一个接口继承一个父接口就会继承父接口中定义的所有方法和属性。
Java中接口的继承是多继承机制，即一个接口可以同时继承多个接口。
接口继承的基本语法 :
interface 接口名 extends 父接口1,父接口2,……{
……
}

15．	Java中接口和抽象类的区别
参考资料：
http://baike.baidu.com/view/3418860.htm
http://zh.wikipedia.org/wiki/%E6%8E%A5%E5%8F%A3_(Java)#.E5.8F.83.E8.80.83.E6.96.87.E7.8D.BB

16．	Object 类：
所有java类是祖先。每个类都使用Object作为超类。所以对象（包括数组）都实现这个类的方法
在不明确给出超类的情况下，java会自动把Object作为要定义类的超类
可以使用类型为Object的变量指向任意类型的对象。

Object()
默认构造方法。
clone() 
创建并返回此对象的一个副本。 
equals(Object obj) 
指示某个其他对象是否与此对象“相等”。 
finalize() 
当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。 
getClass() 
返回一个对象的运行时类。
hashCode() 
返回该对象的哈希码值。
notify() 
唤醒在此对象监视器上等待的单个线程。
notifyAll() 
唤醒在此对象监视器上等待的所有线程。 
toString() 
返回该对象的字符串表示。 
wait() 
导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。
wait(long timeout)
导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。
wait(long timeout, int nanos) 
导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。

17．	向上转型：
既可以使用zilei 强大的功能，又可以chouqu 父类的共同性
a)	定义了一个子类Teacher，继承自Person。
i.	通过Teacher teacher = new Teacher()实例化Teacher对象；
ii.	通过Person p= new Teacher();表示定义了一个Person类型的引用，指向新建的Teacher类型的对象，这就称为”向上转型”；
